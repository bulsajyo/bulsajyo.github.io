---
title: "프로그래머스 자율주행 1주차 1~2일차"
date: 2020-12-02
categories: 파이썬, 자료구조, 알고리즘
---

파이썬의 기본적인 내용
-

데이터 타입: 문자열str, 리스트list, 사전dict, 순서쌍tuple, 집합set, ...

자료구조(data structure): 기본적인 타입으로 해결 못하는 문제를 해결하거나 보다 효율적인 솔루션을 만들기 위함

풀어야 하는 문제가 무엇인지, 어떤 데이터가 있는지, 자료구조가 어떤 성질을 가져야 하는가에 따라

자료구조와 연산을 선택 -> 알고리즘


알고리즘의 복잡도
-

시간 복잡도(time complexity): 코드 다 돌아갈때까지 시간 걸리는 정도

공간 복잡도(space complexity): 코드 실행시 메모리 차지하는 정도

평균 시간 복잡도(average time complexity): 여러 입력 패턴을 줬을 때 소요되는 시간의 평균

최악 시간 복잡도(worst-case time complexity): 가장 긴 시간 소요될 때의 시간

복잡도는 주로 Big-O notation으로 표기 ex) 입력의 크기 n과 비례하는 시간 소요될때 시간 복잡도 = O(n)

알고리즘을 짤때 보다 낮은 복잡도를 갖는 알고리즘을 만드는 것이 좋다

자주 사용되는 알고리즘
-

정렬(sort): 어떤 '기준'에 따라 배열을 새로 늘어놓는 방법

탐색(search): 원하는 요소를 탐색; 선형 탐색(linear search)과 이진 탐색(binary search)을 이용

재귀 알고리즘(recursive algorithms): 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 방법 - 종결조건이 중요

자료 구조들
-

추상적 자료구조: 내부 구현은 숨기고 데이터와 연산들만 보여준다

  1) 선형 배열(Linear Array)

  같은 종류의 데이터를 순서대로 늘어놓은 것

  (파이썬의 리스트는 배열 내 데이터가 모두 같은 타입일 필요는 없다)

  리스트의 연산: ① 원소 덧붙이기(append), ② 끝에서 꺼내기(pop), ③ 중간에 원소 삽입(insert), ④ 중간의 원소 삭제(del), ⑤ 원소 탐색하기(index)

  실행 시간 - ①,② 는 리스트 길이에 관계없음, ③,④,⑤는 리스트 길이가 길면 시간이 더 걸림


  2) 연결 리스트(linked lists)

  데이터와 다음 노드의 정보를 담은 노드들의 리스트

  리스트의 맨 앞(head), 맨 끝(tail), node의 위치 - 이 3가지를 알고 있는게 편함

  연결 리스트의 연산: k번째 원소 참조, 리스트 순회, 총 길이 얻기, 원소 삽입, 원소 삭제, 두 리스트 합치기

  2-2) 양방향 연결 리스트(doubly liked lists)
  
  연결리스트에서 노드들이 앞, 뒤 양 방향으로 갈 수 있게 만들고 head와 tail 더미를 추가해 더 편리해짐
  
  연산은 기존 연결 리스트와 동일
  
  3) 스택(Stacks)
  
  데이터를 보관할 수 있는 선형 구조, 
  한 쪽 끝에서 넣고(push) 넣은 쪽에서 꺼내야 하는(pop) 제약이 있음 -> 후입선출(Last-in First-out; LIFO)
  
  스택의 연산: 총 데이터 수, 현재 스택이 비었는지 확인, 스택 맨 위에 원소 추가, 스택 맨 위의 원소 값 반환&제거, 스택 맨 위 원소 값 반환
  
  파이선의 stack 라이브러리: import pythonds.basic.stack import Stack 으로 사용
  
  4) 큐(Queue)
  
  데이터를 보관할 수 있는 선형 구조,
  한쪽 끝에서 넣고(enqueue) 반대쪽에서 꺼냄(dequeue) -> 선입선출(First-in First-out; FIFO)
  
  큐의 연산: 총 데이터 수, 현재 큐가 비었는지 확인, 큐에 원소 추가, 큐의 맨 앞 원소 값 반환&제거, 큐 맨 앞 원소 값 반환
  
  큐의 사용처:
  
  자료 축적과 자료 이용 작업이 비동기적으로 일어나는 경우, 
  
  자료 축적과 자료 이용이 각각 여러 곳에서 일어나는 경우,
  
  자료를 이용해 어떤 일을 수행하고 그 자료를 나중에 다시 쓸 경우
  
  4-2) 환형 큐(Circular queue)
  
  정해진 개수의 저장공간을 빙 돌려가며 이용하는 큐
  
  큐가 가득차면 더이상 원소 추가 불가 -> 큐 길이 기억 필수
  
  연산은 기존 큐의 연산 + 큐에 데이터 꽉 차있는지 판단 하는 연산 추가
  
  4-3) 우선순위 큐(Priority queue)
  
  FIFO 방식을 따르지 않고 원소들의 우선 순위에 따라 큐에서 빠져나오는 방식,
  
  보통 우선순위 순서 유지하면서 enqueue하는게 시간적으로 유리.
  
  5) 트리(Tree)
  
  정점(node)과 간선(edge)을 이용해 데이터 배치 형태를 추상화한 자료구조
  
  맨 위의 뿌리(root) 노드로부터 아래의 이파리(leaf) 노드까지 가지를 쳐가며 자료를 배치
  
  중간 노드들: 내부(internal) 노드
  
  edge로 위아래로 연결된 노드들 중, 위쪽은 부모(parent)노드, 아래쪽은 자식(child)노드
  
  같은 부모노드를 갖는 노드끼리는 형제관계(sibling)
  
  부모의 부모들: 조상(ancestor), 자식의 자식들: 후손(descendant)
  
  노드의 수준(level): 뿌리에서 0, 잎노드쪽으로 내려갈수록 1씩 증가
  
  트리의 높이(height) 또는 깊이(depth) = 트리 내 최대 수준 + 1
  
  트리의 한 노드와 그 노드에 딸린 자식과 후손들을 따로 떼어 부분 트리(subtree)를 만들 수 있다.
  
  노드의 차수(degree) = 자식의 수 = subtree의 수 
  자식 없는 노드는 degree=0, leaf node
  
  뿌리노드 외의 모든 노드들은 단 하나의 부모 노드를 가짐
  
  트리의 종류:
  
  이진트리(binary tree):
  모든 노드의 차수가 2 이하인 트리 - 재귀적으로 정의 가능
  
  포화 이진트리(full binary tree): 
  모든 레벨의 노드들이 모두 채워져있는 이진트리, 높이가 k이면 총 노드 개수는 2^k-1
  
  완전 이진트리(complete binary tree):
  높이 k인 완전 이진트리, 
  레벨 k-2까지는 포화 이진트리이지만 레벨 k-1에서는 왼쪽부터 순차적으로 노드가 채워지는 구조
  
  이진트리의 연산: 총 노드 수, 현재 트리의 깊이(높이), 순회(traversal)
  
  순회 방법: 중위 순회(왼쪽자식-나-오른쪽자식),
  전위 순회(나-왼쪽자식-오른쪽자식), 
  후위 순회(왼쪽자식-오른쪽자식-나),
  넓이 우선 순회(뿌리-잎, 왼쪽-오른쪽)
  
  5-2) 이진 탐색 트리(binary search tree)
  모든 노드에 대해 왼쪽 서브트리의 데이터는 모두 현재 노드 값보다 작고, 
  오른쪽 서브트리의 데이터는 모두 현재 노드의 값보다 큼; 중복 데이터 없다고 가정
  
  데이터 원소의 추가 및 삭제는 용이하나 공간 소요가 큼
  
  데이터 표현: 각 노드는 key, value 쌍으로.
  
  이진탐색 트리의 연산: 트리에 원소 추가, 특정 원소 삭제, 특정 원소 검색, 키 순서대로 원소 나열, 최소 키, 최대 키 갖는 원소 탐색, 자식 세기
  
  6) 힙(heap)
  
  이진트리의 한 종류,
  루트 노드가 언제나 최댓값(최대 힙), 또는 최솟값(최소 힙)을 가짐,
  완전 이진 트리
  
  같은 레벨끼리는 정렬 안된 느슨한 정렬
  
  힙의 연산: 원소 삽입, 최대원소 반환&노드제거
